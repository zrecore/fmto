<!DOCTYPE html>
<html lang="en">
    <head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" href="/test/img/favicon.ico" type="image/x-icon">
		<title>FMTO - lib/default/default-render.test</title>
		<link rel="stylesheet" type="text/css" href="/test/style.css" />
	</head>
	<body>
		<h1>lib/default/default-storage-buffers.test</h1>
        <a href="/test/">Back to test index</a>
        <p id="testDefaultRender">
            <canvas id="gpuCanvasDefaultRender"></canvas>
        </p>
		<script type="module">
			import {
                Core,
                DefaultRender
            } from '/src/index.mjs'

            async function main() {
                try {
                    const core = new Core()
                    
                    const hasAdapter = await core.initializeAdapter()
                    const hasDevice = await core.initializeDevice()
                    
                    if (hasAdapter && hasDevice) {
                        const device = core.device
                        const canvas = document.getElementById('gpuCanvasDefaultRender')
                        const context = canvas.getContext('webgpu')
                        const presentationFormat = navigator.gpu.getPreferredCanvasFormat()
                        
                        // Create the shader module
                        const shader = `
                            struct VSOutput {
                                @builtin(position) position: vec4f,
                                @location(0) color: vec4f,
                            }
                            struct OurStruct {
                                color: vec4f,
                                offset: vec2f,
                            };

                            struct OtherStruct {
                                scale: vec2f,
                            }

                            @group(0) @binding(0) var<storage, read> ourStructs: array<OurStruct>;
                            @group(0) @binding(1) var<storage, read> otherStructs: array<OtherStruct>; 
    
                            @vertex fn vs(
                                @builtin(vertex_index) vertexIndex : u32,
                                @builtin(instance_index) instanceIndex : u32
                            ) -> VSOutput {
                                let pos = array(
                                    vec2f(0.0, 0.5), // top center
                                    vec2f(-0.5, -0.5), // bottom left
                                    vec2f(0.5, -0.5) // bottom right
                                );

                                let otherStruct = otherStructs[instanceIndex];
                                let ourStruct = ourStructs[instanceIndex];

                                var vsOut : VSOutput;
                                vsOut.position = vec4f(
                                    pos[vertexIndex] * otherStruct.scale + ourStruct.offset,
                                    0.0,
                                    1.0
                                );

                                vsOut.color = ourStruct.color;

                                return vsOut;
                            }
    
                            @fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {
                                return vsOut.color;
                            }
                        `
                        
                        // A random number between [min and max)
                        // With 1 argument it will be [0 to min)
                        // With no arguments it will be [0 to 1)
                        const rand = (min, max) => {
                            if (min === undefined) {
                            min = 0;
                            max = 1;
                            } else if (max === undefined) {
                            max = min;
                            min = 0;
                            }
                            return min + Math.random() * (max - min);
                        };
                        
                        function renderCall() {
                            context.configure({
                                device,
                                format: presentationFormat
                            })
        
                            const view = context
                                .getCurrentTexture()
                                .createView()

                            // Offsets to the various uniform values in float32 indices
                            const kColorOffset = 0
                            const kScaleOffset = 0 // Not 4. Set to 0
                            const kOffsetOffset = 4 // Not 6. Set to 4

                            const kNumObjects = 100
                            const objectInfos = []

                            const staticUnitSize =
                                4 * 4 + // color is 4 32bit floats (4bytes each)
                                2 * 4 + // offset is 2 32bit floats (4bytes each)
                                2 * 4   // padding
                            const changingUnitSize =
                                2 * 4  // scale is 2 32bit floats (4bytes each)

                            const staticStorageBufferSize = staticUnitSize * kNumObjects
                            const changingStorageBufferSize = changingUnitSize * kNumObjects

                            const render = new DefaultRender(
                                device, 
                                view,
                                null,
                                0,
                                shader,
                                "vs",
                                "fs"
                            )

                            const staticStorageBuffer = render.device.createBuffer({
                                label: 'static storage for objects',
                                size: staticStorageBufferSize,
                                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                            })

                            const changingStorageBuffer = render.device.createBuffer({
                                label: 'changing storage for objects',
                                size: changingStorageBufferSize,
                                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                            })
                            
                            

                            render.renderPipelineDescriptorConfig = {
                                label: 'multiple uniform buffer',
                                layout: 'auto',
                                vertex: {
                                    module: render.shaderModule,
                                },
                                fragment: {
                                    module: render.shaderModule,
                                    targets: [{ format: presentationFormat }],
                                },
                            }

                            render.renderPassDescriptorConfig =  {
                                label: 'our basic canvas renderPass',
                                colorAttachments: [
                                    {
                                        view: render.view,

                                        clearValue: [0.3, 0.3, 0.3, 1],
                                        loadOp: 'clear',
                                        storeOp: 'store',
                                    },
                                ],
                            }

                            {
                                const staticStorageValues = new Float32Array(staticStorageBufferSize / 4)
                                for (let i = 0; i < kNumObjects; i++) {
                                    const staticOffset = i * (staticUnitSize / 4)

                                    // These are only set once, so set them now.
                                    staticStorageValues.set([rand(), rand(), rand(), 1], staticOffset + kColorOffset)
                                    staticStorageValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], staticOffset + kOffsetOffset)

                                    objectInfos.push({
                                        scale: rand(0.2, 0.5)
                                    })
                                }
                                render.device.queue.writeBuffer(
                                    staticStorageBuffer,
                                    0,
                                    staticStorageValues
                                )
                            }
                            // A typed array we can use to update the changingStorageBuffer
                            const storageValues = new Float32Array(changingStorageBufferSize / 4)
                            const bindGroup = render.device.createBindGroup({
                                label: 'bind group for objects',
                                layout: render.renderPipeline.getBindGroupLayout(0),
                                entries: [
                                    {
                                        binding: 0,
                                        resource: {
                                            buffer: staticStorageBuffer
                                        }
                                    },
                                    {
                                        binding: 1,
                                        resource: {
                                            buffer: changingStorageBuffer
                                        }
                                    }
                                ]
                            })

                            /*for (let i = 0; i < kNumObjects; ++i) {
                                //
                                const staticUniformBuffer = device.createBuffer({
                                    label: `static uniforms for obj: ${i}`,
                                    size: staticUniformBufferSize,
                                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
                                })
                                // These are set once.
                                {
                                    const uniformValues = new Float32Array( staticUniformBufferSize / 4)
                                    
                                    uniformValues.set([rand(), rand(), rand(), 1], kColorOffset) // Set the color
                                    uniformValues.set([rand(-0.9, 0.9), rand(-0.9, 0.9)], kOffsetOffset) // set the offset

                                    render.device.queue.writeBuffer(staticUniformBuffer, 0, uniformValues)
                                }
                                // Create typedarray to hold the values for the uniforms in Javascript
                                const uniformValues = new Float32Array(uniformBufferSize / 4)
                                const uniformBuffer = render.device.createBuffer({
                                    label: `changing uniforms for obj: ${i}`,
                                    size: uniformBufferSize,
                                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
                                })

                                const bindGroup = render.device.createBindGroup({
                                    label: `bind group for obj: ${i}`,
                                    layout: render.renderPipeline.getBindGroupLayout(0),
                                    entries: [
                                        {
                                            binding: 0,
                                            resource: {
                                                buffer: staticUniformBuffer
                                            }
                                        },
                                        {
                                            binding: 1,
                                            resource :{
                                                buffer: uniformBuffer
                                            }
                                        }
                                    ]
                                })
                                
                                objectInfos.push({
                                    scale: rand(0.2, 0.5),
                                    uniformBuffer,
                                    uniformValues,
                                    bindGroup
                                })
                            }*/
                            
                            const aspect = canvas.width / canvas.height

                            /*for (const {scale, bindGroup, uniformBuffer, uniformValues} of objectInfos) {
                                uniformValues.set([scale / aspect, scale], kScaleOffset) // Set the scale

                                render.device.queue.writeBuffer(uniformBuffer, 0, uniformValues)
                                render.passEncoder.setBindGroup(0, bindGroup)
                                // Render!
                                render.run(3, false, false)
                            }*/
                            objectInfos.forEach(({scale}, ndx) => {
                                const offset = ndx * (changingUnitSize / 4)
                                storageValues.set([scale / aspect, scale], offset + kScaleOffset) // set the scale
                            })
                            // Upload all scales at once
                            render.device.queue.writeBuffer(changingStorageBuffer, 0, storageValues)

                            render.passEncoder.setBindGroup(0, bindGroup)
                            render.run(3, false, false, kNumObjects)
                            
                            render.passEncoder.end()
                            render
                                .device
                                .queue
                                .submit([
                                    render.commandEncoder.finish()
                                ])
                        }
                        
                        const observer = new ResizeObserver(entries => {
                            for (const entry of entries) {

                                const canvas = entry.target
                                const width = entry.contentBoxSize[0].inlineSize
                                const height = entry.contentBoxSize[0].blockSize
                                
                                canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D))
                                canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D))
    
                                renderCall()
                            }
                        })
    
                        observer.observe(canvas)
                    } else {
                        throw "Could not initialize WebGPU adapter or WebGPU device."
                    }
                } catch (ex) {
                    console.error(ex)
                }
			}
            main()

		</script>
	</body>
</html>
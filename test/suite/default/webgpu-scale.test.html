<!DOCTYPE html>
<html lang="en">
    <head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" href="/test/img/favicon.ico" type="image/x-icon">
		<title>FMTO - lib/default/webgpu-scale.test</title>
		<link rel="stylesheet" type="text/css" href="/test/style.css" />
	</head>
	<body>
		<h1>lib/default/webgpu-scale.test</h1>
        <a href="/test/">Back to test index</a>
        <div class="flex">
            <div>
                <div>
                    <label>Translate X</label><input id="translateX" type="number" min="0" max="1000" value="0" />
                </div>
                <div>
                    <label>Translate Y</label><input id="translateY" type="number" min="0" max="1000" value="0" />
                </div>
            </div>
            <div>
                <div>
                    <label>Rotate</label><input id="rotate" type="number" min="0" max="360" value="0" />
                </div>
                <div id="circle"></div>
            </div>
            <div>
                <div>
                    <label>Scale X</label><input id="scaleX" type="number" min="-10" max="10" value="10" />
                </div>
                <div>
                    <label>Scale Y</label><input id="scaleY" type="number" min="-10" max="10" value="10" />
                </div>
            </div>
        </div>
        <p id="testDefaultRender" class="hatched">
            <canvas id="gpuCanvasDefaultRender"></canvas>
        </p>
		<script type="module">
			import {
                Core,
                DefaultRender
            } from '/src/index.mjs'

            function createFVertices() {
                const vertexData = new Float32Array([
                    // left column
                    0, 0,
                    30, 0,
                    0, 150,
                    30, 150,

                    // top rung
                    30, 0,
                    100, 0,
                    30, 30,
                    100, 30,

                    // middle rung
                    30, 60,
                    70, 60,
                    30, 90,
                    70, 90,
                ])

                const indexData = new Uint32Array([
                    0, 1, 2,    2, 1, 3, // left column
                    4, 5, 6,    6, 5, 7, // top rung
                    8, 9, 10,  10, 9, 11, // middle rung
                ])

                return {
                    vertexData, 
                    indexData,
                    numVertices: indexData.length,
                }
            }

            function degToRad(d) {
                return d * Math.PI / 180
            }

            async function main() {
                try {
                    const core = new Core()
                    
                    const hasAdapter = await core.initializeAdapter()
                    const hasDevice = await core.initializeDevice()
                    
                    if (hasAdapter && hasDevice) {
                        const device = core.device
                        const canvas = document.getElementById('gpuCanvasDefaultRender')
                        const context = canvas.getContext('webgpu')
                        const presentationFormat = navigator.gpu.getPreferredCanvasFormat()
                        
                        // Create the shader module
                        const shader = `
                            struct Uniforms {
                                color: vec4f,
                                resolution: vec2f,

                                translation: vec2f,
                                rotation: vec2f,
                                scale: vec2f,
                            };

                            struct Vertex {
                                @location(0) position: vec2f,
                            }

                            struct VSOutput {
                                @builtin(position) position: vec4f,
                            }

                            @group(0) @binding(0) var<uniform> uni: Uniforms;
                            
                            @vertex fn vs(
                                vert: Vertex
                            ) -> VSOutput {

                                var vsOut : VSOutput;

                                let scaledPosition = vert.position * uni.scale;
                                // code
                                //  c s
                                // -s c
                                
                                // math
                                // c -s    x * c + y * -s
                                // s  c    x * s + y * c
                                let rotatedPosition = vec2f(
                                    scaledPosition.x * uni.rotation.x - scaledPosition.y * uni.rotation.y,
                                    scaledPosition.x * uni.rotation.y + scaledPosition.y * uni.rotation.x
                                );
                                
                                let position = rotatedPosition + uni.translation;

                                // convert the position from pixels to a 0.0 to 1.0 value
                                let zeroToOne = position / uni.resolution;

                                // convert from 0 <-> 1 to 0 <-> 2
                                let zeroToTwo = zeroToOne * 2.0;

                                // convert from 0 <-> 2 to -1 <-> +1 (clip space)
                                let flippedClippedSpace = zeroToTwo - 1.0;

                                // flip Y
                                let clipSpace = flippedClippedSpace * vec2f(1, -1);

                                vsOut.position = vec4f(clipSpace, 0.0, 1.0);

                                return vsOut;
                            }
    
                            @fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {
                                return uni.color;
                            }
                        `
                        
                        const settings = {
                            translation: [50, 50],
                            rotation: [1, 0],
                            scale: [1, 1]
                        }

                        const mouse = {
                            isMouseDown: false,
                            isMouseDragging: false,
                            translation: [0, 0]
                        }

                        function handleTranslationChange(ev) {
                            let x = parseFloat(document.getElementById('translateX').value)
                            let y = parseFloat(document.getElementById('translateY').value)

                            if (x < 0) x = 0
                            if (x > 1000) x = 1000

                            if (y < 0) y = 0
                            if (y > 1000) y = 1000

                            settings.translation = [x, y]
                            renderCall()
                        }

                        function handleRotationChange(ev) {
                            let theta = parseFloat(document.getElementById('rotate').value)

                            if (theta < -360) theta = 360
                            if (theta > 360) theta = -360

                            settings.rotation = [ Math.cos(degToRad(theta)), Math.sin(degToRad(theta))]
                            renderCall()
                        }

                        function handleScaleChange(ev) {
                            let x = parseInt(document.getElementById('scaleX').value)
                            let y = parseInt(document.getElementById('scaleY').value)

                            if (x < -10) x = -10
                            if (x > 10) x = 10
                            if (y < -10) y = -10
                            if (y > 10) y = 10

                            settings.scale = [ x / 10, y / 10]
                            console.log(settings.scale)
                            renderCall()
                        }

                        function handleMouseDown(ev) {
                            mouse.isMouseDown = true
                        }

                        function handleMouseUp(ev) {
                            mouse.isMouseDown = false
                        }

                        function handleMouseMove(ev) {
                            mouse.translation = [
                                parseInt(ev.offsetX),
                                parseInt(ev.offsetY)
                            ]

                            if (mouse.isMouseDown) {
                                mouse.isMouseDragging = true
                            } else {
                                mouse.isMouseDragging = false
                            }

                            if (mouse.isMouseDragging) {
                                const controlX = document.getElementById('translateX')
                                const controlY = document.getElementById('translateY')

                                controlX.value = mouse.translation[0]
                                controlY.value = mouse.translation[1]

                                if (controlX.value < 0) controlX.value = 0
                                if (controlX.value > 1000) controlX.value = 1000
                                if (controlY.value < 0) controlY.value = 0
                                if (controlY.value > 1000) controlY.value = 1000

                                handleTranslationChange()
                            }
                        }

                        function setupTranslationControls() {
                            const controlX = document.getElementById('translateX')
                            const controlY = document.getElementById('translateY')

                            controlX.value = settings.translation[0]
                            controlY.value = settings.translation[1]
                            
                            controlX.addEventListener("change", handleTranslationChange)
                            controlY.addEventListener("change", handleTranslationChange)

                            canvas.addEventListener("mousedown", handleMouseDown)
                            canvas.addEventListener("mouseup", handleMouseUp)
                            canvas.addEventListener("mousemove", handleMouseMove)
                        }

                        function setupRotationControls() {
                            const control = document.getElementById('rotate')

                            control.value = Math.atan2(settings.rotation[1], settings.rotation[0])

                            control.addEventListener("change", handleRotationChange)
                        }

                        function setupScaleControls() {
                            const controlX = document.getElementById('scaleX')
                            const controlY = document.getElementById('scaleY')

                            controlX.value = settings.scale[0] * 10
                            controlY.value = settings.scale[1] * 10

                            controlX.addEventListener("change", handleScaleChange)
                            controlY.addEventListener("change", handleScaleChange)
                        }
                        
                        function renderCall() {
                            context.configure({
                                device,
                                format: presentationFormat,
                                alphaMode: 'premultiplied'
                            })
                            
                            const view = context
                                .getCurrentTexture()
                                .createView()

                            // Offsets to the various uniform values in float32 indices
                            const kColorOffset = 0
                            const kResolutionOffset = 4
                            const kTranslationOffset = 6
                            const kRotationOffset = 8
                            const kScaleOffset = 10

                            const { vertexData, indexData, numVertices } = createFVertices()
                            
                            const render = new DefaultRender(
                                device, 
                                view,
                                null,
                                0,
                                shader,
                                "vs",
                                "fs"
                            )

                            render.renderPipelineDescriptorConfig = {
                                label: 'just 2d position',
                                layout: 'auto',
                                vertex: {
                                    module: render.shaderModule,

                                    buffers: [
                                        {
                                            arrayStride: (2) * 4, // 2 floats, 4 bytes each
                                            attributes: [
                                                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // position (shaderLocation of 0 is @location(0))
                                            ]
                                        }
                                    ]

                                },
                                fragment: {
                                    module: render.shaderModule,
                                    targets: [{ format: presentationFormat }],
                                },
                            }

                            render.renderPassDescriptorConfig =  {
                                label: 'our basic canvas renderPass',
                                colorAttachments: [
                                    {
                                        view: render.view,

                                        loadOp: 'clear',
                                        storeOp: 'store',
                                    },
                                ],
                            }

                            // color, resolution, translation, rotation, padding
                            const uniformBufferSize = (4 + 2 + 2 + 2 + 2) * 4
                            const uniformBuffer = render.device.createBuffer({
                                label: 'uniforms',
                                size: uniformBufferSize,
                                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                            })
                            const uniformValues = new Float32Array(uniformBufferSize / 4)

                            const colorValue = uniformValues.subarray(kColorOffset, kColorOffset + 4)
                            const resolutionValue = uniformValues.subarray(kResolutionOffset, kResolutionOffset + 2)
                            const translationValue = uniformValues.subarray(kTranslationOffset, kTranslationOffset + 2)
                            const rotationValue = uniformValues.subarray(kRotationOffset, kRotationOffset + 2)
                            const scaleValue = uniformValues.subarray(kScaleOffset, kScaleOffset + 2)

                            // The color will not change so let's set it once at init time
                            colorValue.set([
                                Math.random(),
                                Math.random(),
                                Math.random(),
                                1
                            ])

                            // A typed array we can use to update the changingVertexBuffer
                            const vertexBuffer = render.device.createBuffer({
                                label: 'vertex buffer',
                                size: vertexData.byteLength,
                                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
                            })

                            render.device.queue.writeBuffer(vertexBuffer, 0, vertexData)

                            const indexBuffer = render.device.createBuffer({
                                label: 'index buffer',
                                size: indexData.byteLength,
                                usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
                            })

                            render.device.queue.writeBuffer(indexBuffer, 0, indexData)

                            const bindGroup = render.device.createBindGroup({
                                label: 'bind group for object',
                                layout: render.renderPipeline.getBindGroupLayout(0),
                                entries: [
                                    { binding: 0, resource: { buffer: uniformBuffer } }
                                ]
                            })
                            
                            const aspect = canvas.width / canvas.height

                            render.passEncoder.setPipeline(render.renderPipeline)
                            render.passEncoder.setVertexBuffer(0, vertexBuffer)
                            render.passEncoder.setIndexBuffer(indexBuffer, 'uint32')

                            // set the uniform values in our Javascript side Float32Array
                            resolutionValue.set([canvas.width, canvas.height])
                            translationValue.set(settings.translation)
                            rotationValue.set(settings.rotation)
                            scaleValue.set([settings.scale[0], settings.scale[1]])

                            render.device.queue.writeBuffer(uniformBuffer, 0, uniformValues)

                            render.passEncoder.setBindGroup(0, bindGroup)
                            render.passEncoder.drawIndexed(numVertices)

                            render.passEncoder.end()
                            render
                                .device
                                .queue
                                .submit([
                                    render.commandEncoder.finish()
                                ])
                        }
                        
                        const observer = new ResizeObserver(entries => {
                            for (const entry of entries) {

                                const canvas = entry.target
                                const width = entry.contentBoxSize[0].inlineSize
                                const height = entry.contentBoxSize[0].blockSize
                                
                                canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D))
                                canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D))

                                renderCall()
                            }
                        })
    
                        observer.observe(canvas)

                        setupTranslationControls()
                        setupRotationControls()
                        setupScaleControls()
                    } else {
                        throw "Could not initialize WebGPU adapter or WebGPU device."
                    }
                } catch (ex) {
                    console.error(ex)
                }
			}

            document.onreadystatechange = () => {
                console.log("document.readyState", document.readyState)
                if (document.readyState == "complete" ) {
                    main()
                }
            }

		</script>
	</body>
</html>
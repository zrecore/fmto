<!DOCTYPE html>
<html lang="en">
    <head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" href="/test/img/favicon.ico" type="image/x-icon">
		<title>FMTO - lib/default/default-render.test</title>
		<link rel="stylesheet" type="text/css" href="/test/style.css" />
	</head>
	<body>
		<h1>lib/default/default-vertex-buffers.test</h1>
        <a href="/test/">Back to test index</a>
        <p id="testDefaultRender">
            <canvas id="gpuCanvasDefaultRender"></canvas>
        </p>
		<script type="module">
			import {
                Core,
                DefaultRender
            } from '/src/index.mjs'

            async function main() {
                try {
                    const core = new Core()
                    
                    const hasAdapter = await core.initializeAdapter()
                    const hasDevice = await core.initializeDevice()
                    
                    if (hasAdapter && hasDevice) {
                        const device = core.device
                        const canvas = document.getElementById('gpuCanvasDefaultRender')
                        const context = canvas.getContext('webgpu')
                        const presentationFormat = navigator.gpu.getPreferredCanvasFormat()
                        
                        // Create the shader module
                        const shader = `
                            
                            struct Vertex {
                                @location(0) position: vec2f,
                                @location(1) color: vec4f,
                                @location(2) offset: vec2f,
                                @location(3) scale: vec2f,
                                @location(4) perVertexColor: vec3f,
                            }

                            struct VSOutput {
                                @builtin(position) position: vec4f,
                                @location(0) color: vec4f,
                            }

                            @vertex fn vs(
                                vert: Vertex
                            ) -> VSOutput {

                                var vsOut : VSOutput;
                                vsOut.position = vec4f(
                                    vert.position * vert.scale + vert.offset,
                                    0.0,
                                    1.0
                                );

                                vsOut.color = vert.color * vec4f(vert.perVertexColor, 1);

                                return vsOut;
                            }
    
                            @fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {
                                return vsOut.color;
                            }
                        `

                        function createCircleVertices({
                            radius = 1,
                            numSubdivisions = 24,
                            innerRadius = 0,
                            startAngle = 0,
                            endAngle = Math.PI * 2,
                        } = {}) {
                            // 2 vertices at each subdivision, +1 to wrap around the circle
                            const numVertices = (numSubdivisions + 1) * 2
                            const vertexData = new Float32Array(numVertices * (2 + 1))
                            const colorData = new Uint8Array(vertexData.buffer)

                            let offset = 0
                            let colorOffset = 8

                            const addVertex = (x, y, r, g, b) => {
                                vertexData[offset++] = x
                                vertexData[offset++] = y
                                offset += 1 // skip the color
                                colorData[colorOffset++] = r * 255
                                colorData[colorOffset++] = g * 255
                                colorData[colorOffset++] = b * 255
                                colorOffset += 9
                            }

                            const innerColor = [1, 1, 1]
                            const outerColor = [0.1, 0.1, 0.1]

                            // 2 triangles per subdivision
                            // 
                            // 0 2 4 6 8 ...
                            //
                            // 1 3 5 7 9 ...
                            for (let i = 0; i <= numSubdivisions; ++i) {
                                const angle = startAngle + (i + 0) * (endAngle - startAngle) / numSubdivisions

                                const c1 = Math.cos(angle)
                                const s1 = Math.sin(angle)

                                addVertex(c1 * radius, s1 * radius, ...outerColor)
                                addVertex(c1 * innerRadius, s1 * innerRadius, ...innerColor)
                            }

                            const indexData = new Uint32Array(numSubdivisions * 6)
                            let ndx = 0

                            // 1st tri.  2nd tri.  3rd tri.  4th tri.
                            // 0 1 2     2 1 3     2 3 4     4 3 5
                            //
                            // 0--2         2      2--4         4      .....
                            // | /         /|      | /         /|
                            // |/         / |      |/         / |
                            // 1         1--3      3         3--5      .....
                            for (let i = 0; i < numSubdivisions; ++i) {
                                const ndxOffset = i * 2;

                                // first triangle
                                indexData[ndx++] = ndxOffset
                                indexData[ndx++] = ndxOffset + 1
                                indexData[ndx++] = ndxOffset + 2

                                // second triangle
                                indexData[ndx++] = ndxOffset + 2
                                indexData[ndx++] = ndxOffset + 1
                                indexData[ndx++] = ndxOffset + 3
                            }
                            return {
                                vertexData,
                                indexData,
                                numVertices: indexData.length
                            }
                        }

                        // A random number between [min and max)
                        // With 1 argument it will be [0 to min)
                        // With no arguments it will be [0 to 1)
                        const rand = (min, max) => {
                            if (min === undefined) {
                                min = 0
                                max = 1
                            } else if (max === undefined) {
                                max = min
                                min = 0
                            }
                            return min + Math.random() * (max - min)
                        };
                        
                        function renderCall() {
                            context.configure({
                                device,
                                format: presentationFormat
                            })
        
                            const view = context
                                .getCurrentTexture()
                                .createView()

                            // Offsets to the various uniform values in float32 indices
                            const kColorOffset = 0
                            const kScaleOffset = 0
                            const kOffsetOffset = 1

                            const kNumObjects = 100
                            const objectInfos = []

                            const staticUnitSize =
                                4 +     // color is 4 32bit floats (4bytes each)
                                2 * 4   // offset is 2 32bit floats (4bytes each)
                            const changingUnitSize =
                                2 * 4  // scale is 2 32bit floats (4bytes each)

                            const staticVertexBufferSize = staticUnitSize * kNumObjects
                            const changingVertexBufferSize = changingUnitSize * kNumObjects

                            const render = new DefaultRender(
                                device, 
                                view,
                                null,
                                0,
                                shader,
                                "vs",
                                "fs"
                            )

                            const { vertexData, indexData, numVertices } = createCircleVertices({
                                radius: 0.5,
                                innerRadius: 0.25
                            })

                            const staticVertexBuffer = render.device.createBuffer({
                                label: 'static vertex for objects',
                                size: staticVertexBufferSize,
                                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                            })

                            const changingVertexBuffer = render.device.createBuffer({
                                label: 'changing vertex for objects',
                                size: changingVertexBufferSize,
                                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                            })
                            
                            

                            render.renderPipelineDescriptorConfig = {
                                label: 'per vertex colors',
                                layout: 'auto',
                                vertex: {
                                    module: render.shaderModule,

                                    buffers: [
                                        {
                                            arrayStride: 2 * 4 + 4, // 2 floats, 4 bytes each + 4 bytes
                                            attributes: [
                                                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // position (shaderLocation of 0 is @location(0))
                                                { shaderLocation: 4, offset: 8, format: 'unorm8x4' }, // perVertexColor
                                            ]
                                        },
                                        {
                                            arrayStride: 4 + 2 * 4, // 4 bytes + 2 floats, 4 bytes each
                                            stepMode: 'instance',
                                            attributes: [
                                                { shaderLocation: 1, offset: 0, format: 'unorm8x4' }, // color
                                                { shaderLocation: 2, offset: 4, format: 'float32x2' }, // offset
                                            ],
                                        },
                                        {
                                            arrayStride: 2 * 4, // 2 floats, 4 bytes each
                                            stepMode: 'instance',
                                            attributes: [
                                                { shaderLocation: 3, offset: 0, format: 'float32x2' }, // scale
                                            ]
                                        }
                                    ]

                                },
                                fragment: {
                                    module: render.shaderModule,
                                    targets: [{ format: presentationFormat }],
                                },
                            }

                            render.renderPassDescriptorConfig =  {
                                label: 'our basic canvas renderPass',
                                colorAttachments: [
                                    {
                                        view: render.view,

                                        clearValue: [0.3, 0.3, 0.3, 1],
                                        loadOp: 'clear',
                                        storeOp: 'store',
                                    },
                                ],
                            }

                            {
                                const staticVertexValuesU8 = new Uint8Array(staticVertexBufferSize)
                                const staticVertexValuesF32 = new Float32Array(staticVertexValuesU8.buffer)

                                for (let i = 0; i < kNumObjects; i++) {
                                    const staticOffsetU8 = i * staticUnitSize
                                    const staticOffsetF32 = staticOffsetU8 / 4

                                    // These are only set once, so set them now.
                                    staticVertexValuesU8.set( // Set the color
                                        [rand() * 255, rand() * 255, rand() * 255, 255],
                                        staticOffsetU8 + kColorOffset
                                    )
                                    staticVertexValuesF32.set(
                                        [rand(-0.9, 0.9), rand(-0.9, 0.9)],
                                        staticOffsetF32 + kOffsetOffset
                                    )

                                    objectInfos.push({
                                        scale: rand(0.2, 0.5)
                                    })
                                }
                                render.device.queue.writeBuffer(
                                    staticVertexBuffer,
                                    0,
                                    staticVertexValuesF32
                                )
                            }
                            // A typed array we can use to update the changingVertexBuffer
                            const vertexValues = new Float32Array(changingVertexBufferSize / 4)
                            
                            const vertexBuffer = render.device.createBuffer({
                                label: 'vertex buffer',
                                size: vertexData.byteLength,
                                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
                            })

                            render.device.queue.writeBuffer(vertexBuffer, 0, vertexData)

                            const indexBuffer = render.device.createBuffer({
                                label: 'index buffer',
                                size: indexData.byteLength,
                                usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
                            })

                            render.device.queue.writeBuffer(indexBuffer, 0, indexData)
                            
                            const aspect = canvas.width / canvas.height

                            render.passEncoder.setVertexBuffer(0, vertexBuffer)
                            render.passEncoder.setVertexBuffer(1, staticVertexBuffer)
                            render.passEncoder.setVertexBuffer(2, changingVertexBuffer)
                            render.passEncoder.setIndexBuffer(indexBuffer, 'uint32')

                            objectInfos.forEach(({scale}, ndx) => {
                                const offset = ndx * (changingUnitSize / 4)
                                vertexValues.set([scale / aspect, scale], offset + kScaleOffset) // set the scale
                            })
                            // Upload all scales at once
                            render.device.queue.writeBuffer(changingVertexBuffer, 0, vertexValues)

                            render.run(numVertices, false, false, kNumObjects, true)
                            
                            render.passEncoder.end()
                            render
                                .device
                                .queue
                                .submit([
                                    render.commandEncoder.finish()
                                ])
                        }
                        
                        const observer = new ResizeObserver(entries => {
                            for (const entry of entries) {

                                const canvas = entry.target
                                const width = entry.contentBoxSize[0].inlineSize
                                const height = entry.contentBoxSize[0].blockSize
                                
                                canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D))
                                canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D))
    
                                renderCall()
                            }
                        })
    
                        observer.observe(canvas)
                    } else {
                        throw "Could not initialize WebGPU adapter or WebGPU device."
                    }
                } catch (ex) {
                    console.error(ex)
                }
			}
            main()

		</script>
	</body>
</html>